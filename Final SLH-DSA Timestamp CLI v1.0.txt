```toml
[package]
name = "final_cli_v1.0_std"
version = "1.0.0"
edition = "2021"

[dependencies]
post_quantum_crypto = { path = "../post_quantum_crypto" }
sha3 = "0.10"
chrono = "0.4"
serde_json = "1.0"
serde = { version = "1.0", features = ["derive"] }
clap = "4.0"
```

```rust
use post_quantum_crypto::apps::timestamp::SlhDsaTimestamp;
use sha3::{Sha3_256, Digest};
use chrono::Utc;
use serde::{Serialize, Deserialize};
use std::fs;
use clap::{Arg, Command};

#[derive(Serialize, Deserialize)]
struct Proof {
    signature: String,
    public_key: String,
    file_hash: String,
    timestamp: String,
    filename: String,
}

fn main() {
    let matches = Command::new("FINAL_Cli_v1.0_std")
        .subcommand(Command::new("timestamp").arg(Arg::new("file").required(true)))
        .subcommand(Command::new("verify").arg(Arg::new("file").required(true)).arg(Arg::new("proof").required(true)))
        .get_matches();

    let timestamp_app = SlhDsaTimestamp::new();
    match matches.subcommand() {
        Some(("timestamp", args)) => timestamp_file(&timestamp_app, args.value_of("file").unwrap()),
        Some(("verify", args)) => verify_timestamp(&timestamp_app, args.value_of("file").unwrap(), args.value_of("proof").unwrap()),
        _ => println!("Usage: timestamp <file> or verify <file> <proof.json>"),
    }
}

fn hash(data: &[u8]) -> String {
    let mut hasher = Sha3_256::new();
    hasher.update(data);
    format!("{:x}", hasher.finalize())
}

fn timestamp_file(app: &SlhDsaTimestamp, file: &str) {
    let data = fs::read(file).unwrap();
    let (sig, pk, h, ts) = app.timestamp_file(&data).unwrap();
    let proof = Proof {
        signature: hex::encode(&sig),
        public_key: hex::encode(&pk),
        file_hash: h,
        timestamp: ts,
        filename: file.to_string(),
    };
    let json = serde_json::to_string_pretty(&proof).unwrap();
    fs::write(format!("{}.timestamp.json", file), json).unwrap();
    println!("Timestamped: {}.timestamp.json", file);
}

fn verify_timestamp(app: &SlhDsaTimestamp, file: &str, proof_file: &str) {
    let data = fs::read(file).unwrap();
    let json = fs::read_to_string(proof_file).unwrap();
    let proof: Proof = serde_json::from_str(&json).unwrap();
    let sig = hex::decode(&proof.signature).unwrap();
    let pk = hex::decode(&proof.public_key).unwrap();
    if app.verify_timestamp(&data, &sig, &pk, &proof.file_hash, &proof.timestamp).unwrap() {
        println!("Verified");
    } else {
        println!("Failed");
    }
}
```

---

**FINAL_Cli_v1.0_std**  
- `./final_cli_v1.0_std timestamp document.pdf` → `document.pdf.timestamp.json`  
- `./final_cli_v1.0_std verify document.pdf document.pdf.timestamp.json` → Verified  

---

**Build & Run:**
```bash
cargo build --release
./target/release/final_cli_v1.0_std timestamp file.pdf
```

---

**Next?**  
Say: **Make GUI**  
→ I give you **FINAL_Gui_v1.0_core**

**Go.**